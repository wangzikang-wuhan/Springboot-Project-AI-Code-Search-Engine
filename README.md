# Springboot-Project-AI-Code-Search-Engine
这是一个微型AI驱动的SpringBoot项目代码搜索引擎，采用自定义代码切割策略+向量化+LLM描述构建代码知识库，实现语义搜索。

这是本人学习过程中的一个练手项目，也算是一个实现笔记。看到自己写的SpringBoot项目和代码然后突然就到去想实现这么一个AI驱动的SpringBoot项目代码搜索引擎，举个例子假如我拿到一个非常陌生的项目我估计会看得很懵需要花大量时间去搞清楚比如这段代码是在干什么之类的，可能也有其他的用处，所以就想到做这么一个东西出来。目前是只能支持SpringBoot项目的代码搜索，后续也可以添加更多语言的支持。

#### 项目架构

1. SpringBoot 项目 
2. [解析器] 提取 .java + 方法 +SpringBoot配置文件+pom.xml+Mapper.xml
3.  [LLM] 生成自然语言描述      
4. [向量化] jina-code + SPLADE 实现混合搜索
5. [Qdrant] 混合检索      
6. 输入：“怎么退款？” 
7. 返回代码片段 + 描述

#### 实现过程：

- 代码切割

  我这里目前只考虑到SpringBoot项目，后续可能会添加更多的代码适配。这里使用JavaLang这个工具，可以对.java文件解析，然后生成一颗语法树。在语法树内部会包含该.java文件几乎所有的信息，注解、方法、参数...所有的信息都在其中，但是唯独不包含方法的完整片段。

  所以得自己去实现切割的方式，代码的切割和PDF文档等数据的切割有些不太一样的是。可能一整个类可以当作一整个代码片段，也有可能一个方法是一整个代码片段，还有可能一整个.java文件都是一个代码片段还有.xml等文件。你如何去设计切割的规则而保证这一整段代码是有效而且AI能看懂是在干什么，这里是值得思考的。我的代码实现中并没有考虑的非常多，想着的是以实现为主。

  我的规则是：

  1. pom.xml直接存一整个，没必要切割
  2. application.yaml等配置文件，直接存一整个，配置文件没有切割的必要
  3. 接口直接存整个.java文件的内容，接口可能是DAO、Service等等
  4. 枚举类直接存整个
  5. 抽象类需要解析并切割
  6. 普通类(我这里分为实体类和普通类)，实体类就是类似于Entity直接存一整个，普通类就需要解析然后切割代码片段，这里的普通类可能是util、serviceImpl、controller等等
  7. mapper.xml直接存一整个文件

- LLM代码描述

  将代码段以及其他数据结合到提示词中，发给AI让它去解析这段代码是在干什么作用是什么，将返回的数据填充到payload中保存起来搜索的时候就可以用到。以下是我使用的提示词：

  ```python
  prompt_template = PromptTemplate.from_template(
      """
      你是一名资深的Java开发者，熟悉Spring Boot项目结构。
      请根据以下信息，用一段话简洁描述该代码片段的核心作用。
      只描述实际功能，不要编造未出现的内容。
      项目信息：
      -项目名称:{projectName}
      -文件名称:{fileName}
      -文件类型:{fileType}
      -具体路径:{path}
      
      代码内容：
      {content}
      """
  )
  ```

- 代码片段向量化

  这一步需要将代码段以及描述信息进行向量化，我分别使用jinaai/jina-embeddings-v2-base-code向量模型和prithivida/Splade_PP_en_v1向量模型分别对代码段和描述信息进行向量化，并且将前者当做稠密向量后者当作稀疏向量。将向量数据和payload一起存储到向量数据库Qdrant中。

- 语义搜索

  这里是同时根据两种向量进行混合检索，之前我试过调整两种向量搜索的权重一直报错，实际上好像调整召回文档的数量好像也是能达到调整权重的效果。

  Springboot项目结构：
  ![](C:\Users\ADMIN\Desktop\modle\springboot项目结构.png) 

  搜索示例：
  ![](C:\Users\ADMIN\Desktop\modle\搜索结果1.png)

  ![搜索结果2](C:\Users\ADMIN\Desktop\modle\搜索结果2.png) 

- 使用方法

  打开ai_code_search_engine/constant/constant.py修改里面的Qdrant配置信息，还有一些参数可以自己调整一下，还有如果你使用的不是ZhiPuAI的话你只需要改一下调用的LLM就行了。

- 总结

  目前只是一个玩具项目还有很多地方要优化，还有一些功能暂时还没想好如何实现。例如在修改代码后该如何去同步到向量数据库中，就是说我得知道哪个地方的代码被修改了，有一种方法就是删除对应文件的所有向量数据重新解析。还有如果要支持其他的语言的话，得写不同的项目解析器而且有些项目的结构并不是都一样，这个就不是很好弄。还有有些代码段很长一个方法非常长，这个要是一次性全部填到上下文里面是不是容易超出限制了，所以这个地方切割策略该怎么弄。